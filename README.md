# ATM Communication Project: Design Document

## 1. Overall System Design
This project implements a secure ATM communication protocol between two programs: atm (client) and bank (server). The system is designed to ensure secure transactions (account creation, deposits, withdrawals, and balance checks) over an open network, protecting against Man-in-the-Middle (MITM) attacks and unauthorized access. Below is an overview of our approach:

### 1.1 Components
- Bank Server (bank): A TCP server that listens on a specific port (default: 3000), manages customer accounts, and processes transactions. It generates an `auth file` on startup for mutual authentication with `atm` clients.
- ATM Client (atm): A client that connects to the `bank` over TCP, allowing users to perform transactions using a `card file` as a credential.
- Communication Channel: Messages are exchanged over TCP with encryption and authentication to ensure confidentiality, integrity, and authenticity.

### 1.2 Protocol Overview
The protocol uses a request-response model where `atm` sends transaction requests to `bank`, and `bank` responds with the results. Key features include:
- Mutual authentication: Both `atm` and `bank` authentiucate each other using a shared secret in the `auth file`.
- Encryption: All messages are encrypted to prevent eavesdropping.
- Message Integrity: Each message includes a Message Authentication Code (MAC) to detect tampering.
- Sequence Numbers: Prevent deplay attacks by ensuring message freshness.

### 1.3 Implementation Details
- Language:
- Libraries: OpenSSL for encryption (AES-256-CBC) and HMAC-SHA256 for integrity.
- Message Format: JSON payloads wrapped in a custom binary envelope.

## 2. Protocol Description
### 2.1 Message Format
Each message consists of:
- Header
	- Sequence Number (4 bytes): Incremented per transaction to prevent replays.
	- Message Length (4 bytes): Length of encrypted payload.
	- MAC (8 bytes (truncated) or 32 bytes): (Truncated) HMAC-SHA256 of the encrypted payload.
- Payload: AES-256-CBC encrypted JSON data
	Example: { "operation": "deposit", "account": "bob", "amount": 100.00 }

### 2.2 Auth File and Card File
- Auth File: Generated by `bank` on startup, contains a 32-byte random key used for AES encryption and HMAC. Shared with `atm` via a trusted channel.
- Card File: Created by `atm` during account creation (`-n`), contains a 16-byte random PIN unique to the account, encrypted with the `auth file` key.

### 2.3 Transaction Flow
1. Startup:
- `bank` generates `auth file` and prints "created".
- `atm` reads `auth file` and connects to `bank`.

2. Authentication:
- `atm` sends an encrypted challenge (random nonce).
- `bank` decrypts, increments nonce, re-encrypts, and sends it back.
- `atm` verifies response to confirm `bank`'s identity.

3. Transaction:
- `atm` sends encrypted request (example: deposit, withdraw).
- `bank` processes request, updates blaance, and sends encrypted response.
- Both output JSON summary (Example: { "account": "bob", "deposit": 100.00 } )

### 2.4 Security Protections
- Confidentiality: AES-256-CBC encryption hides message contents.
- Integrity: HMAC-SHA256 ensures messages aren't altered.
- Authentication: `auth file` key and `card file` PIN validate parties.
- Replay Prevention: Sequence numbers ensure message uniqueness.

## 3. Specific Attacks and Countermeasures

Below are four attacks we've considered, with countermeasures implemented in our design.

### 3.1. Attack 1: MITM Eavesdropping
An MITM intercepts traffic to learn account balances or transaction amounts.

Countermeasure: All messages are encrypted with AES-256-CBC using the `auth file` key. Without the key, the MITM cannot decrypt the payload.
Code: encrypt_message() in file crypto.?
Status: To implement

### 3.2 Attack 2: Replay Attack
An MITM replays a previous deposit request to increase an account balance.

Countermeasure: Each messages includes a sequence number, incremented per transaction. `bank` rejects messages with duplicate or out-of-order sequence numbers.
Code: check_sequence_number() in file ?
Status: To implement

### 3.3 Attack 3: Unauthorized Account Access
An attacker forges a `card file` to withdraw money from an account.

Countermeasure: The `card file` contains a PIN encrypted with the `auth file` key. `bank` verifies the PIN matches the account's stored value before processing requests.
Code: verify_card_file() in file ?

### 3.4 Attack 4: Message Tampering
An MITM alters a withdrawal amount (Example: from 10.00 to 1000.00).

Countermeasure: HMAC-SHA256 is computed over the encrypted payload and verified by the receiver. Tampered messages fail validation, triggering a protocol error (exit code 63 for `atm`, "protocol error" for `bank`).
Code: compute_hmac() and verify_hmac() in crypto.?
Status: To implement

## 4. Additional Nots
- Error Handling: Invalid inputs (e.g. malformed JSON, missing `card file`) results in exit code 255. Protocol errors (e.g. timeouts, tampering) use exit code 63.
- Prevent Denial of Service: `bank` can never exit with an error code or otherwise. That would be considered a denial of service attack.




